module options/member-protected-access

test on member modifier - protected [[
#member-protected-access: allow

class A {
  protected var x = 42
}
class B : public A {
  public foo(a: A) {
    return a.x
  }
}
]]
analysis succeeds
test on member modifier - protected internal [[
#member-protected-access: allow

module p {
  class A {
    protected internal var x = 42
  }
}
module q {
  import p
  class B : public A {
    public foo(a: A) {
      return a.x
    }
  }
}
]]
analysis succeeds

// inheritance modifier

test on inheritance modifier - instance of current - no [[
#member-protected-access: if-instance-of-current

module p {
class A {
  internal var x = 43
}
class B : protected A { }
class C : public B {
  public foo(a: B) {
    return a.x
  }
}
}
]]
analysis fails

test on inheritance modifier - instance of current - exact - yes [[
#member-protected-access: if-instance-of-current

module p {
class A {
  public var x = 42
}
class B : protected A { }
class C : public B {
  public foo(a: C) {
    return a.x
  }
}
}
]]
analysis succeeds

test on inheritance modifier - instance of current - sub - yes [[
#member-protected-access: if-instance-of-current

module p {
class A {
  public var x = 42
}
class B : protected A {
  public foo(a: C) {
    return a.x
  }
}
class C : public B {}
}
]]
analysis succeeds

test on inheritance modifier - allow [[
#member-protected-access: allow

module p {
class A {
  public var x = 42
}
class B : protected A { }
class C : public B {
  public foo(a: B) {
    return a.x
  }
}
}
]]
analysis succeeds

// private members

test private protected member access [[
#member-protected-access: allow

class A {
  private protected var x = 42
}
class B : public A {
  public getX(a: A) {
    return a.x
  }
}
]]
analysis succeeds

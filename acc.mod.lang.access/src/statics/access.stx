module statics/access

imports

  statics/base
  statics/modules
  statics/classes
  statics/options

signature
  sorts PATH_LIST = list((path * scope))

  name-resolution
    labels
      MODULE                // module included in access

  sorts ACCESS constructors
    LOCAL                   :          ACCESS
    UNRESTRICTED            :          ACCESS // PUB in paper
    SUBCLASS_OR_MODULES     : scope -> ACCESS
    SUBCLASS_IN_MODULES     : scope -> ACCESS
    MODULES                 : scope -> ACCESS

  sorts PATHLEVEL constructors
    PRIV_PARENT  : PATHLEVEL
    PRIV_CURRENT : PATHLEVEL
    PROT         : PATHLEVEL
    PUB          : PATHLEVEL

rules

  subclassInModules: list(scope) -> ACCESS
  subclassOrModules: list(scope) -> ACCESS
  modules: list(scope) -> ACCESS

  subclassOrModules(mods) = SUBCLASS_OR_MODULES(s_mods) :-
    new s_mods,
    moduleAccessesOk(s_mods, mods).

  subclassInModules(mods) = SUBCLASS_IN_MODULES(s_mods) :-
    new s_mods,
    moduleAccessesOk(s_mods, mods).

  modules(mods) = MODULES(s_mods) :-
    new s_mods,
    moduleAccessesOk(s_mods, mods).

  moduleAccessOk: scope * scope
  moduleAccessesOk maps moduleAccessOk(*, list(*))

  moduleAccessOk(s, s_mod) :-
    s -MODULE-> s_mod.

rules

  modulesOfAccess: ACCESS -> scope
  modulesOfAccess(SUBCLASS_OR_MODULES(s)) = s.
  modulesOfAccess(SUBCLASS_IN_MODULES(s)) = s.
  modulesOfAccess(MODULES(s)) = s.

rules

  pathLevel    : path          -> PATHLEVEL
  paths : scope * scope -> (PATH_LIST * PATHLEVEL)
  nonEmpty : PATH_LIST

  pathLevel(p) = L :- {R}
    (R, L) == paths(src(p), dst(p)),
    nonEmpty(R).


  paths(s, s_tgt) = paths_1(s, s_tgt, R) :-
    query ()
      // try public paths first 
      filter
        LEX*
        EXTEND*
      and
        { s' :- s' == s_tgt }
      in s |-> R.
      
    paths_1 : scope * scope * PATH_LIST -> (PATH_LIST * PATHLEVEL)
    paths_2 : scope * scope * PATH_LIST -> (PATH_LIST * PATHLEVEL)
    paths_3 : scope * scope * PATH_LIST -> (PATH_LIST * PATHLEVEL)
    
    paths_1(_, _, R@[_|_]) = (R, PUB()).
    paths_1(s, s_tgt, []/* <= no public paths */) = paths_2(s, s_tgt, R) :-
      query () 
      // try protected paths next 
        filter
          LEX*       
          (EXTEND | EXTEND_PROT)*
        and
          { s' :- s' == s_tgt }
        in s |-> R.
    		
    
    paths_2(_, _, R@[_|_]) = (R, PROT()).
    paths_2(s, s_tgt, []/* <= no protected paths*/) = paths_3(s, s_tgt, R) :-
      // try private paths last
      query () 
        filter
          LEX*
          EXTEND_PRIV
          (EXTEND | EXTEND_PROT)*
        and
          { s' :- s' == s_tgt }
        in s |-> R.
    

    paths_3(_, _, R@[_|_]) = (R, PRIV_CURRENT()).
    paths_3(s, s_tgt, []/* <= no current private paths*/) = (R, PRIV_PARENT()) :-
      // try private paths last
      query () 
        filter
          LEX*
          (EXTEND | EXTEND_PROT | EXTEND_PRIV)*
        and
          { s' :- s' == s_tgt }
        in s |-> R.


  nonEmpty([_|_]).
  nonEmpty([]) :- false.
  
rules

  accessModifierToAccess : scope * AccessModifier -> ACCESS
  resolveModRef: scope * ModuleRef -> scope
  resolveModRefs maps resolveModRef(*, list(*)) = list(*)
  modRefOk: scope * scope * ExposureRange * QId
  
  
  [A-Pub]  accessModifierToAccess(s, Public())                   = UNRESTRICTED().
  accessModifierToAccess(s, ProtectedInternal(modRefs)) = subclassOrModules(resolveModRefs(s, modRefs)).
  [A-Int]  accessModifierToAccess(s, Internal(modRefs))          = modules(resolveModRefs(s, modRefs)).
  [A-Prot] accessModifierToAccess(s, Protected())                = subclassOrModules([]).
  accessModifierToAccess(s, PrivateProtected(modRefs))  = subclassInModules(resolveModRefs(s, modRefs)).
  [A-Priv] accessModifierToAccess(s, Private())                  = modules([]).

  resolveModRef(s, Self()) = thisMod(s).
  resolveModRef(s, ModuleRef(qid)) = s_mod :-
    s_mod == resolveMod(s, qid),
    modRefOk(s, s_mod, resolveExposureRange(s), qid).

  modRefOk(s, s_mod, All(), _).
  
  [A-Int'] // Additional condition only
  modRefOk(s, s_mod, Ancestors(), id) :-
    isEnclosingScope(s, s_mod)
    | error $[Not allowed to expose member to non-ancestor module [id].].

  internalPathOk  : InternalAccess * path * /* exposedModules */scope -> PATH_LIST
  
  internalPathOk(AllowInternalAccess(), p, s_mods) = R :-
    query () filter e and { s' :- exposedTo(src(p), s_mods) } in new |-> R.
    
  internalPathOk(IfChainInModule(), p, s_mods) = R :-
    query () filter e and { s' :- allExposedTo(p, s_mods) } in new |-> R.
    

rules // member access

  accessOk       : scope * path * ACCESS

  accessOk(s, p, LOCAL()).

  accessOk(s, p, UNRESTRICTED()) :-
  	pathLevelOk(pathLevel(p), s, p).

  accessOk(s, p, SUBCLASS_OR_MODULES(mods)) :- {REF_OK}
    pathLevelOk(pathLevel(p), s, p),
    exposedToModules(s, mods) == REF_OK,
    subclassOrModulesAccessOk(REF_OK, s, p).

  	  subclassOrModulesAccessOk  : PATH_LIST * scope * path

	  // Accept if the variable is not protected by the instance
	  // and the definition is exposed to the current module.
	  subclassOrModulesAccessOk([_|_], _, _).
	
	  // Member access is not allowed as `internal`, check if it can be accessed as `protected` instead.
	  subclassOrModulesAccessOk(_, s, p) :-
	    // member access of protected member should be allowed
	    protectedAccessOk(resolveProtectedAccess(s), s, p).

  accessOk(s, p, SUBCLASS_IN_MODULES(mods)) :- {W}
    exposedToModules(s, mods) != [],
    internalPathOk(resolveInternalAccess(s), p, mods) != [],
	// Access of protected member should be allowed
	protectedAccessOk(resolveProtectedAccess(s), s, p),
	pathLevelOk(pathLevel(p), s, p).

  accessOk(s, p, MODULES(mods)) :- {L REF_OK PATH_OK}
    pathLevelOk(pathLevel(p), s, p),
    exposedToModules(s, mods) == REF_OK,
    internalPathOk(resolveInternalAccess(s), p, mods) == PATH_OK,
    modulesAccessOk(REF_OK, PATH_OK, s, p).

      modulesAccessOk : PATH_LIST * PATH_LIST * scope * path

      modulesAccessOk([_|_], [_|_],_, _).
      modulesAccessOk(_, _, s, p) :-
	    // member access of 'private' member should be allowed
  	    privateAccessOk(resolvePrivateAccess(s), s, /* private in declaration scope */ dst(p), p).


rules // path validation

  pathLevelOk: PATHLEVEL * /*s ref*/scope * path

  pathLevelOk(PUB(), _, _).

  pathLevelOk(PROT(), s, p) :-
    protectedAccessOk(resolveProtectedAccess(s), s, p).
  
  pathLevelOk(_, s, p) :- {s_this}
    s_this == thisClass(s),
    // must be private in this very class (not necessarily in instance class `src(p)`)
    privateInCurrent(s_this, dst(p)),
    privateAccessOk(resolvePrivateAccess(s), s, s_this, p).
	

  protectedAccessOk : ProtectedAccess * scope * path
  
  protectedAccessOk(IfInstanceOfDefining(), s, p) :-
    nonEmpty(subClass(thisClass(s), dst(p))).

  protectedAccessOk(IfInstanceOfCurrent(), s, p) :-
    nonEmpty(subClass(thisClass(s), dst(p))),
    nonEmpty(subClass(thisClass(src(p)), thisClass(s))).

  privateInCurrent: scope * scope

  privateInCurrent(s_inst, s_decl) :- {R}
    query ()
      filter
        LEX*
        EXTEND_PRIV
        (EXTEND | EXTEND_PROT)*
      and
        { s' :- s' == s_decl }
      in s_inst |-> R,
    nonEmpty(R).


  privateAccessOk   : PrivateAccess * scope * scope * path

  privateAccessOk(IfExactType(), s_ref, s_priv, p) :-
    s_priv == thisClass(s_ref), 	// access must occur in the class in which the reference is private
    s_priv == thisClass(src(p)).	// instance of var must be scope in which it is private 

  privateAccessOk(IfSubtypeOfCurrent(), s_ref, s_priv, p) :-
    s_priv == thisClass(s_ref), 			// access must occur in the class in which the reference is private
    nonEmpty(subClass(src(p), s_priv)).		// instance of var must be a subclass of the class in which the variable is private


rules

  allExposedTo : path * scope
  allExposedTo_ : path * scope
  exposedTo: /*s_src*/scope * /*modules*/scope
  exposedToModules: /*s_src*/scope * /*modules*/scope -> PATH_LIST
  isExposedTo: scope * scope * ExposureMode

  allExposedTo(_PathEmpty(_), _). /* same class visibility is always allowed */
  allExposedTo(p, s_mods) :- allExposedTo_(p, s_mods).
  allExposedTo_(_PathEmpty(s), s_mods) :- exposedTo(s, s_mods).
  allExposedTo_(_PathStep(p, _, s), s_mods) :-
    exposedTo(s, s_mods),
    allExposedTo_(p, s_mods).

  exposedTo(s, s_mods) :-
    nonEmpty(exposedToModules(s, s_mods)).

  exposedToModules(s, s_mods) = MS:- {M}
    M == resolveExposureMode(s),

    query ()
      filter MODULE
        and { m :- isExposedTo(s, m, M) }
      in s_mods |-> MS.

  isExposedTo(s, m, DirectChildOnly()) :-
    thisMod(s) == m.

  isExposedTo(s, m, IncludeSubmodules()) :-
    isEnclosingScope(s, m).

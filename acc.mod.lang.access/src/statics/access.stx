module statics/access

imports

  statics/base
  statics/modules
  statics/classes

rules

  lexicalPaths   : scope * scope -> list((path * scope))
  memberPaths    : scope * scope -> list((path * scope))
  
  lexicallyVisible : path
  memberVisible    : path

  nonEmptyPathList : list((path * scope))

  lexicalPaths(s, s_tgt) = R :-
    query () 
      filter
        LEX*
        EXTEND_PRIV?
        (EXTEND | EXTEND_PROT)*
      and
      	{ s :- s == s_tgt }
      in s |-> R.

  memberPaths(s, s_tgt) = R :-
    query () 
      filter
        EXTEND*
      and
      	{ s :- s == s_tgt }
      in s |-> R.

  lexicallyVisible(p) :- nonEmptyPathList(lexicalPaths(src(p), dst(p))).
  memberVisible(p)    :- nonEmptyPathList(memberPaths(src(p), dst(p))).
  nonEmptyPathList([_|_]).
  nonEmptyPathList([]) :- false.

rules

  accessModifierToAccess : scope * AccessModifier -> ACCESS
  resolveModRef: scope * ModuleRef -> scope
  resolveModRefs maps resolveModRef(*, list(*)) = list(*)
  
  accessModifierToAccess(s, Public()) 					= memberAccess([rootScope(s)], SUBCLASSACCESS()).
  accessModifierToAccess(s, ProtectedInternal(modRefs)) = memberAccess(resolveModRefs(s, modRefs), SUBCLASSACCESS()).
  accessModifierToAccess(s, Internal(modRefs)) 			= memberAccess(resolveModRefs(s, modRefs), NOSUBCLASSACCESS()).
  accessModifierToAccess(s, Protected()) 				= memberAccess([], SUBCLASSACCESS()).
  accessModifierToAccess(s, PrivateInternal(modRefs))   = memberAccess(resolveModRefs(s, modRefs), MODULESUBCLASSACCESS()).
  accessModifierToAccess(s, Private()) 					= memberAccess([], NOSUBCLASSACCESS()).

  resolveModRef(s, Self()) = thisMod(s).
  resolveModRef(s, ModuleRef(qid)) = resolveMod(s, qid).

rules

  lexicalAccessOk :         path * ACCESS
  memberAccessOk  : scope * path * ACCESS

  lexicalAccessOk(p, LOCAL()).

  lexicalAccessOk(p, MEMBER(s_mods, SUBCLASSACCESS())) :-
    lexicallyVisible(p).

  lexicalAccessOk(p, MEMBER(s_mods, MODULESUBCLASSACCESS())) :-
    lexicallyVisible(p),
    allExposedTo(p, s_mods).

  lexicalAccessOk(p, MEMBER(s_mods, NOSUBCLASSACCESS())) :-
    thisClass(src(p)) == thisClass(dst(p)).


  memberAccessOk(_, _, LOCAL()).

  memberAccessOk(_, p, MEMBER(s_mods, MODULESUBCLASSACCESS())) :-
    false.

  memberAccessOk(s, p, MEMBER(mods, _)) :-
    memberVisible(p),
    nonEmptyPathList(exposedTo(s, mods)).

rules

  lexicallyVisibleOrInExposedModule : 

rules

  allExposedTo : path * scope
  exposedTo: /*s_src*/scope * /*modules*/scope -> list((path * scope))

  allExposedTo(_PathEmpty(_), _).
  allExposedTo(_PathStep(p, _, s), s_mods) :-
    nonEmptyPathList(exposedTo(s, s_mods)),
    allExposedTo(p, s_mods).

  exposedTo(s, s_mods) = MS :-
    query ()
      filter MODULE
        and { m :- 
          query ()
		    filter LEX* and { m' :- m' == m }
		    in s |-> [_|_]
		}
      in s_mods |-> MS.

rules

  nonEmpty : list((path * scope)) -> B
  nonEmpty([_ | _]) = T().
  nonEmpty([]) = F().

rules // paths

  dst: path -> scope
  src: path -> scope
  
  dst(_PathEmpty(s)) = s.
  dst(_PathStep(_, _, s)) = s.
  
  src(_PathEmpty(s)) = s.
  src(_PathStep(p, _, _)) = src(p).

signature
  sorts B constructors
    T : B
    F : B

rules // logic

  isTrue: B
  isTrue(b) :-
    try { b == T() }.

  andB  : B * B
  andB_ : B * B -> B
  
  andB(b1, b2) :-
  	isTrue(andB_(b1, b2)).
  andB_(T(), T()) = T().
  andB_(_, _) = F().
  
  orB  : B * B
  orB_ : B * B -> B

  orB(b1, b2) :-
  	isTrue(orB_(b1, b2)).
  orB_(T(), _) = T().
  orB_(_, T()) = T().
  orB_(_, _) = F().
  

  allB : list(B)
  allB_: list(B) -> B
  
  allB(bs) :-
  	isTrue(allB_(bs)).
  allB_([]) = T().
  allB_([b | bs]) = andB_(b, allB_(bs)).
  

  anyB : list(B)
  anyB_: list(B) -> B
  
  anyB(bs) :-
  	isTrue(allB_(bs)).
  anyB_([]) = T().
  anyB_([b | bs]) = orB_(b, anyB_(bs)).

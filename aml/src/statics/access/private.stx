module statics/access/private

imports
 
  statics/base
  statics/classes
  statics/options

  statics/access/base
  statics/access/auxiliary
  statics/access/internal // To reduce `PRV` to `MOD []`.
  
rules
 
  [A-Priv]
  accessModifierToAccess(s, Private()) = modules([]).

rules

  privateAccessOk   : PrivateAccess * scope * scope * path * path * MODE

  privateAccessOk(IfExactType(), s_ref, s_priv, p_cls_to_var, p_full, m) :-
    privateScopeOk(resolvePrivateScope(s_ref), s_ref, s_priv),						// access must occur in the class in which the reference is private
	noSubclassInPath(p_cls_to_var, p_full, s_priv, m).								// assert that no class in the path is a subclass of the defining class

  privateAccessOk(IfSubtypeOfCurrent(), s_ref, s_priv, p_cls_to_var, p_full, m) :-
    privateScopeOk(resolvePrivateScope(s_ref), s_ref, s_priv),						// access must occur in the class in which the reference is private
    nonEmpty(subClass(thisClass(src(p_full)), s_priv)).        						// instance of var must be a subclass of the class in which the variable is private

rules // subclass check

  noSubclassInPath: path * path * scope * MODE
  
  noSubclassInPath(p_cls_to_var, p_full, s, LEX()) :-
    query thisClass
      filter LEX* and { s_cls :- s_cls == s }
      in src(p_full) |-> [_].

  noSubclassInPath(_PathEmpty(s), _, s_prnt, _).

rules

  privateScopeOk: PrivateScope * scope * scope

  privateScopeOk(Innermost(), s_cls_ref, s_cls_decl) :-
    isEnclosingClass(thisClass(s_cls_ref), s_cls_decl).

  privateScopeOk(Outermost(), s_cls_ref, s_cls_decl) :-
    outerClass(s_cls_ref) == outerClass(s_cls_decl).

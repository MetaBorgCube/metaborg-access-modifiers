module statics/access/private

imports
 
  statics/base
  statics/classes
  statics/options

  statics/access/base
  statics/access/auxiliary
  statics/access/internal // To reduce `PRV` to `MOD []`.
  
rules
 
  [A-Priv]
  accessModifierToAccess(s, Private()) = modules([]).

rules

  privateAccessOk   : PrivateAccess * scope * scope * path * MODE

  privateAccessOk(IfExactType(), s_ref, s_priv, p, m) :-
    privateScopeOk(resolvePrivateScope(s_ref), s_ref, s_priv),		// access must occur in the class in which the reference is private
	noSubclassInPath(p, s_priv, m).									// assert that no class in the path is a subclass of the defining class

  privateAccessOk(IfSubtypeOfCurrent(), s_ref, s_priv, p, m) :-
    privateScopeOk(resolvePrivateScope(s_ref), s_ref, s_priv),		// access must occur in the class in which the reference is private
    nonEmpty(subClass(thisClass(src(p)), s_priv)).        			// instance of var must be a subclass of the class in which the variable is private

rules // subclass check

  noSubclassInPath: path * scope * MODE
  
  noSubclassInPath(p, s, LEX()) :-
    query thisClass
      filter LEX* and { s_cls :- s_cls == s }
      in src(p) |-> [_].

  // no EXT-steps in path
  noSubclassInPath(_PathEmpty(s), s_prnt, _).

rules

  privateScopeOk: PrivateScope * scope * scope

  privateScopeOk(Innermost(), s_cls_ref, s_cls_decl) :-
    isEnclosingClass(thisClass(s_cls_ref), s_cls_decl).

  privateScopeOk(Outermost(), s_cls_ref, s_cls_decl) :-
    outerClass(s_cls_ref) == outerClass(s_cls_decl).

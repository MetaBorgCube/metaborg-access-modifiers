module statics/methods

imports

  signatures/start-sig

  statics/base
  statics/types

signature
  
  sorts METHOD constructors
    METHOD : list(TYPE) * TYPE -> METHOD

  relations
    method : ID * scope -> METHOD

rules

  declareMethod: scope * scope * ID * list(TYPE) * TYPE -> scope
  declareMethod(s_cls, s, x, T_args, T_ret) = s_mthd_id :-
    new s_mthd_id,
    resolveLocalMethod(s_cls, x) == [_] | error $[Duplicate Declaration of Method [x].],
    !method[x, s_mthd_id, METHOD(T_args, T_ret)] in s.

rules // locally declared methods (for duplication checking)

  resolveLocalMethod: scope * ID -> list((path * (ID * scope * METHOD)))

  resolveLocalMethod(s, x) = R :-
    query method
      filter ( PROTECTED
             | INTERNAL
             | PROTECTED_INTERNAL
             | PRIVATE_INTERNAL
             | PRIVATE
             )?
        and { (x', _) :- x' == x }
      in s |-> R.

rules // references (with/without) receivers

  resolveLexicalMethod : scope * ID -> METHOD
  resolveMemberMethod  : scope * ID -> METHOD

  resolveLexicalMethod(s, x) = T :- {x'}
    query method
      filter
        LEX*
        PARENT?
        PRIVATE?
        ( PARENT | PROTECTED | PROTECTED_INTERNAL | EXTENDS_INTERNAL )*
        ( ( PARENT | PROTECTED_INTERNAL | PROTECTED | EXTENDS | EXTENDS_INTERNAL )*
        | ( PARENT | EXTENDS_INTERNAL | PROTECTED | INTERNAL | PROTECTED_INTERNAL | PRIVATE_INTERNAL)*
        )
      and
        { (x', _) :- x' == x }
      min
        PROTECTED < PARENT,
        INTERNAL < PARENT,
        PRIVATE < PARENT,
        PROTECTED_INTERNAL < PARENT,
        PRIVATE_INTERNAL < PARENT,

        $ < PROTECTED,
        $ < INTERNAL,
        $ < PRIVATE,
        $ < PROTECTED_INTERNAL,
        $ < PRIVATE_INTERNAL,
        
        $ < LEX
      in s |-> [(_, (x', _, T))]
      | error $[Reference to method [x] is ambiguous.],
    @x.ref := x'.

  resolveMemberMethod(s, x) = T :- {x'}
    query method
      filter
        ( (PARENT | EXTENDS | EXTENDS_INTERNAL)*
        | (PARENT | EXTENDS_INTERNAL | PROTECTED_INTERNAL | INTERNAL)*
        )
      and
        { (x', _) :- x' == x }
      min
        INTERNAL < EXTENDS, 
        INTERNAL < EXTENDS_INTERNAL,
        
        PROTECTED_INTERNAL < EXTENDS, 
        PROTECTED_INTERNAL < EXTENDS_INTERNAL,
        
        $ < INTERNAL,
        $ < PROTECTED_INTERNAL,
        
        $ < LEX
      in s |-> [(_, (x', _, T)) | _]
      | error $[Reference to method [x] is ambiguous.],
    @x.ref := x'.

rules // resolve ignore visibility

  resolveAllParentMethods : scope * ID -> list((path * (ID * scope * METHOD)))
  resolveParentMethods    : scope * ID -> list((path * (ID * scope * METHOD)))

  resolveAllParentMethods(s, x) = R :-
    query method
      filter
        LEX*
        PARENT
        ( PROTECTED
        | INTERNAL
        | PROTECTED_INTERNAL
        | PRIVATE_INTERNAL
        | PRIVATE
        )?
        ( EXTENDS   | EXTENDS_INTERNAL)
        ( PARENT
        | EXTENDS   | EXTENDS_INTERNAL
        | PROTECTED | INTERNAL | PROTECTED_INTERNAL | PRIVATE_INTERNAL | PRIVATE
        )*
      and
        { (x', _) :- x' == x }
      min
        PROTECTED < PARENT,
        INTERNAL < PARENT,
        PRIVATE < PARENT,
        PROTECTED_INTERNAL < PARENT,
        PRIVATE_INTERNAL < PARENT,

        $ < PROTECTED,
        $ < INTERNAL,
        $ < PRIVATE,
        $ < PROTECTED_INTERNAL,
        $ < PRIVATE_INTERNAL,
        
        $ < LEX
      in s |-> R.

  resolveParentMethods(s, x) = R :-
    query method
      filter
        LEX*
        PARENT
        ( PROTECTED
        | INTERNAL
        | PROTECTED_INTERNAL
        | PRIVATE_INTERNAL
        | PRIVATE
        )?
        ( EXTENDS   | EXTENDS_INTERNAL)
        ( PARENT | PROTECTED | PROTECTED_INTERNAL | EXTENDS_INTERNAL )*
        ( ( PARENT | PROTECTED_INTERNAL | PROTECTED | EXTENDS | EXTENDS_INTERNAL )*
        | ( PARENT | EXTENDS_INTERNAL | PROTECTED | INTERNAL | PROTECTED_INTERNAL | PRIVATE_INTERNAL)*
        )
      and
        { (x', _) :- x' == x }
      min
        PROTECTED < PARENT,
        INTERNAL < PARENT,
        PRIVATE < PARENT,
        PROTECTED_INTERNAL < PARENT,
        PRIVATE_INTERNAL < PARENT,

        $ < PROTECTED,
        $ < INTERNAL,
        $ < PRIVATE,
        $ < PROTECTED_INTERNAL,
        $ < PRIVATE_INTERNAL,
        
        $ < LEX
      in s |-> R.

rules

  // resolving methods that have a particular accessibility level or higher!
  accessibilityElevationOk : scope * AccessModifier * scope

  // Can always elevate to Public
  accessibilityElevationOk(_, Public(), _).

  // Can elevate to `protected internal` unless it was public
  accessibilityElevationOk(s, ProtectedInternal(), id) :-
    query method
      filter
        LEX*
        (PARENT (EXTENDS | EXTENDS_INTERNAL))*
      and
        { (_, id') :- id' == id }
      min
        $ < LEX,
        $ < EXTENDS,
        $ < EXTENDS_INTERNAL
      in s |-> [].

  accessibilityElevationOk(s, Protected(), id) :-
    query method
      filter
        LEX*
        ( PARENT
        | INTERNAL 
        | PROTECTED_INTERNAL
        )?
        ( (PROTECTED_INTERNAL | PARENT | EXTENDS_INTERNAL)*
           EXTENDS          (PARENT | PROTECTED_INTERNAL | EXTENDS  | EXTENDS_INTERNAL)*
        |  EXTENDS_INTERNAL (PARENT | PROTECTED_INTERNAL | INTERNAL | EXTENDS_INTERNAL)*
        )
      and
        { (_, id') :- id' == id }
      min
        PROTECTED < PARENT,
        INTERNAL < PARENT,
        PROTECTED_INTERNAL < PARENT,

        $ < PROTECTED,
        $ < INTERNAL,
        $ < PROTECTED_INTERNAL,
        
        $ < LEX
      in s |-> [].

  accessibilityElevationOk(s, Internal(), id) :-
    query method
      filter
        LEX*
        ( PARENT
        | PROTECTED
        | PROTECTED_INTERNAL
        )?
        ( EXTENDS | EXTENDS_INTERNAL)
        ( PROTECTED_INTERNAL | PROTECTED | EXTENDS | EXTENDS_INTERNAL )*
      and
        { (_, id') :- id' == id }
      min
        PROTECTED < PARENT,
        INTERNAL < PARENT,
        PROTECTED_INTERNAL < PARENT,

        $ < PROTECTED,
        $ < INTERNAL,
        $ < PROTECTED_INTERNAL,
        
        $ < LEX
      in s |-> [].

  accessibilityElevationOk(s, PrivateInternal(), id) :-
    query method
      filter
        LEX*
        ( PARENT
        | PROTECTED
        | INTERNAL
        | PROTECTED_INTERNAL
        | PRIVATE_INTERNAL
        )?
        ( (PARENT | PROTECTED | PROTECTED_INTERNAL | EXTENDS          | EXTENDS_INTERNAL)*
        | (PARENT | INTERNAL  | PROTECTED_INTERNAL | PRIVATE_INTERNAL | EXTENDS_INTERNAL)*
        )
      and
        { (_, id') :- id' == id }
      min
        INTERNAL < PARENT,
        PROTECTED_INTERNAL < PARENT,
        PRIVATE_INTERNAL < PARENT,

        $ < INTERNAL,
        $ < PROTECTED_INTERNAL,
        $ < PRIVATE_INTERNAL,
        
        $ < LEX
      in s |-> [].

  accessibilityElevationOk(s, Private(), id) :-
    query method
      filter
        LEX*
        ( PARENT | PROTECTED | PROTECTED_INTERNAL | EXTENDS_INTERNAL )*
        ( ( PARENT | PROTECTED_INTERNAL | PROTECTED | EXTENDS | EXTENDS_INTERNAL )*
        | ( PARENT | EXTENDS_INTERNAL | PROTECTED | INTERNAL | PROTECTED_INTERNAL | PRIVATE_INTERNAL)*
        )
      and
        { (_, id') :- id' == id }
      min
        PROTECTED < PARENT,
        INTERNAL < PARENT,
        PRIVATE < PARENT,
        PROTECTED_INTERNAL < PARENT,
        PRIVATE_INTERNAL < PARENT,

        $ < PROTECTED,
        $ < INTERNAL,
        $ < PRIVATE,
        $ < PROTECTED_INTERNAL,
        $ < PRIVATE_INTERNAL,
        
        $ < LEX
      in s |-> [].

rules

  overrideOk: METHOD * METHOD

  overrideOk(METHOD(T_args, T_ret), METHOD(T_args', T_ret')) :-
    allContravariant(T_args, T_args') | error $[Method argument count does not match overridden method.],
    covariant(T_ret, T_ret').

  covariant: TYPE * TYPE
  contravariant: TYPE * TYPE
  
  allCovariant maps covariant(list(*), list(*))
  allContravariant maps contravariant(list(*), list(*))

  covariant(T, T')     :- subtype(T, T') | error $[[T] is not a subtype of [T'].].
  contravariant(T, T') :- subtype(T', T) | error $[[T'] is not a subtype of [T].].

module statics/classes

imports

  signatures/start-sig

  statics/base
  statics/types
  statics/variables
  statics/methods
  statics/expressions
  statics/modules

signature

  relations
    class: ID -> scope
    thisClass: scope
    extends: ID // track double extension

rules

  declareClass: scope * ID * scope
  resolveClass: scope * ID -> list((path * (ID * scope)))
  scopeOfClassRef: scope * ID -> scope

  declareClass(s, x, s_cls) :-
    // TODO: duplicate check.
    !class[x, s_cls] in s,
    !thisClass[s_cls] in s_cls.

  resolveClass(s, x) = R :-
    query class
      filter LEX* IMPORT?
        and { x' :- x' == x }
      min
        $ < LEX, LEX < IMPORT
      in s |-> R.

  scopeOfClassRef(s, x) = s_cls :- {x'}
    resolveClass(s, x) == [(_, (x', s_cls)) | _],
    @x.ref := x'.

rules

  thisClass: scope -> scope
  thisClass(s) = s_cls :-
    query thisClass
      filter LEX*
      min $ < LEX
      in s |-> [(_, s_cls) | _].

rules

  classOk: scope * Class
  classOk(s, Class(x, extends, members)) :- {s_pub}
    new s_pub,
    declareClass(s, x, s_pub),
    
    s_pub -LEX-> s,

    extendsOk(s_pub, extends),   
    membersOk(s_pub, members).

    
rules

  extendsOk: scope * Extends
  extendsClauseOk: scope * ExtendsClause
  extendsClausesOk maps extendsClauseOk(*, list(*))
  extend: /* class name */ID * /* source module */scope * /* target module */scope * /* class scope*/scope * /* source scope */scope * /* target scope */scope
  noDuplExtend: scope * ID

  extendsOk(_, NoExtends()).
  extendsOk(s_pub, Extends(clauses)) :-
    extendsClausesOk(s_pub, clauses).

  extendsClauseOk(s_pub, ExtendsClause(Public(), x)) :- {s_tgt}
    scopeOfClassRef(s_pub, x) == s_tgt,
    extend(x, thisMod(s_pub), thisMod(s_tgt), s_pub, s_pub, s_tgt).

  extendsClauseOk(s_pub, ExtendsClause(Protected(), x)) :- {s_tgt s_prot}
    scopeOfClassRef(s_pub, x) == s_tgt,
    new s_prot, s_pub -PROTECTED-> s_prot,
    extend(x, thisMod(s_pub), thisMod(s_tgt), s_pub, s_prot, s_tgt).

  extendsClauseOk(s_pub, ExtendsClause(Internal(), x)) :- {s_tgt s_int}
    scopeOfClassRef(s_pub, x) == s_tgt,
    new s_int, s_pub -INTERNAL-> s_int,
    extend(x, thisMod(s_pub), thisMod(s_tgt), s_pub, s_int, s_tgt).

  extendsClauseOk(s_pub, ExtendsClause(Private(), x)) :- {s_tgt s_priv}
    scopeOfClassRef(s_pub, x) == s_tgt,
    new s_priv, s_pub -PRIVATE-> s_priv,
    extend(x, thisMod(s_pub), thisMod(s_tgt), s_pub, s_priv, s_tgt).

  extendsClauseOk(s_pub, ExtendsClause(ProtectedInternal(), x)) :- {s_tgt s_prot_int}
    scopeOfClassRef(s_pub, x) == s_tgt,
    new s_prot_int, s_pub -PROTECTED_INTERNAL-> s_prot_int,
    extend(x, thisMod(s_pub), thisMod(s_tgt), s_pub, s_prot_int, s_tgt).

  extendsClauseOk(s_pub, ExtendsClause(PrivateInternal(), x)) :- {s_tgt s_priv_int}
    scopeOfClassRef(s_pub, x) == s_tgt,
    new s_priv_int, s_pub -PRIVATE_INTERNAL-> s_priv_int,
    extend(x, thisMod(s_pub), thisMod(s_tgt), s_pub, s_priv_int, s_tgt).

  extend(x, s_mod, s_mod, s_cls, s_src, s_tgt) :-
    noDuplExtend(s_cls, x),
    s_src -EXTENDS_INTERNAL-> s_tgt.

  extend(x, _, _, s_cls, s_src, s_tgt) :-
    noDuplExtend(s_cls, x),
    s_src -EXTENDS-> s_tgt.

  noDuplExtend(s, x) :-
    !extends[x] in s,
    query extends
      filter e and { x' :- x' == x } in s |-> [_]
      | error $[Extending [x] multiple times.].

rules

  memberOk: scope * MemberDecl
  membersOk maps memberOk(*, list(*))

  memberOk(s_cls, Field(acc, x, init)) :- {T}
    typeOfExpr(s_cls, init) == T,
    fieldDeclOk(s_cls, acc, x, T).

  memberOk(s_pub, Method(acc, mth, x, args, stmts, ret_exp)) :- 
    {s_mthd s_mthd_id Ts T_ret}
      new s_mthd,
      s_mthd -LEX-> s_pub,
    
      argumentsOk(s_mthd, args) == Ts,
    
      typeOfExpr(s_mthd, ret_exp) == T_ret,
      
      stmtsOk(s_mthd, stmts),
      
      methodModOk(s_pub, acc, mth, x, Ts, T_ret),
    
      methodDeclOk(s_pub, acc, x, Ts, T_ret) == s_mthd_id.

rules

  fieldDeclOk: scope * AccessModifier * ID * TYPE

  fieldDeclOk(s_pub, Public(), x, T) :-
    declareVar(s_pub, s_pub, x, T).

  fieldDeclOk(s_pub, Protected(), x, T) :- {s_prot}
    new s_prot, s_pub -PROTECTED-> s_prot,
    declareVar(s_pub, s_prot, x, T).
 
  fieldDeclOk(s_pub, Internal(), x, T) :- {s_int}
    new s_int, s_pub -INTERNAL-> s_int,
    declareVar(s_pub, s_int, x, T).

  fieldDeclOk(s_pub, Private(), x, T) :- {s_priv}
    new s_priv, s_pub -PRIVATE-> s_priv,
    declareVar(s_pub, s_priv, x, T).

  fieldDeclOk(s_pub, ProtectedInternal(), x, T) :- {s_prot_int}
    new s_prot_int, s_pub -PROTECTED_INTERNAL-> s_prot_int,
    declareVar(s_pub, s_prot_int, x, T).

  fieldDeclOk(s_pub, PrivateInternal(), x, T) :- {s_priv_int}
    new s_priv_int, s_pub -PRIVATE-> s_priv_int,
    declareVar(s_pub, s_priv_int, x, T).

rules

  argumentOk : scope * Arg -> TYPE
  argumentsOk maps argumentOk(*, list(*)) = list(*)

  argumentOk(s, Arg(x, t)) = T :-
    typeOfType(s, t) == T,
    declareVar(s, s, x, T).

rules

  stmtOk : scope * Stmt
  stmtsOk maps stmtOk(*, list(*))

  stmtOk(s, ExprStmt(exp)) :-
    typeOfExpr(s, exp) == _.

  stmtOk(s, Assign(recv, exp)) :- {T_recv T_exp}
    typeOfLHS(s, recv) == T_recv,
    typeOfExpr(s, exp) == T_exp,
    subtype(T_recv, T_exp).

rules

  methodModOk : scope * AccessModifier * MethodModifier * ID * list(TYPE) * TYPE

  methodModOk(s, _, n@NoMethodModifier(), x, _, _) :-
    resolveAllParentMethods(s, x) == []  | error $[Overriding Parent Method.] @n.

  methodModOk(s, _, n@New(), x, _, _) :-
    resolveAllParentMethods(s, x) == [_] | error $[No Parent Method to Override.] @n.

  methodModOk(s, acc, o@Override(), x, Ts, T) :- {M}
    resolveParentMethods(s, x) == M,
    try { M != [] } | error $[No method found to override] @o,
    overridesCompat(s, o, acc, METHOD(Ts, T), M).

rules

  overrideCompat : scope * MethodModifier * AccessModifier * METHOD * (path * (ID * scope * METHOD)) 
  overridesCompat maps overrideCompat(*, *, *, *, list(*))

  overrideCompat(s, mod, acc, M, (_, (_, id, M'))) :-
    accessibilityElevationOk(s, acc, id) | error $[Cannot restrict access level of overriding method to [acc].] @acc,
    overrideOk(M, M').

rules

  methodDeclOk: scope * AccessModifier * ID * list(TYPE) * TYPE -> scope

  methodDeclOk(s_pub, Public(), x, T_args, T) = s_mthd_id :-
    declareMethod(s_pub, s_pub, x, T_args, T) == s_mthd_id.

  methodDeclOk(s_pub, Protected(), x, T_args, T) = s_mthd_id :- {s_prot}
    new s_prot, s_pub -PROTECTED-> s_prot,
    declareMethod(s_pub, s_prot, x, T_args, T) == s_mthd_id.

  methodDeclOk(s_pub, Internal(), x, T_args, T) = s_mthd_id :- {s_int}
    new s_int, s_pub -INTERNAL-> s_int,
    declareMethod(s_pub, s_int, x, T_args, T) == s_mthd_id.

  methodDeclOk(s_pub, Private(), x, T_args, T) = s_mthd_id :- {s_priv}
    new s_priv, s_pub -PRIVATE-> s_priv,
    declareMethod(s_pub, s_priv, x, T_args, T) == s_mthd_id.

  methodDeclOk(s_pub, ProtectedInternal(), x, T_args, T) = s_mthd_id :- {s_prot_int}
    new s_prot_int, s_pub -PROTECTED_INTERNAL-> s_prot_int,
    declareMethod(s_pub, s_prot_int, x, T_args, T) == s_mthd_id.

  methodDeclOk(s_pub, PrivateInternal(), x, T_args, T) = s_mthd_id :- {s_priv_int}
    new s_priv_int, s_pub -PRIVATE_INTERNAL-> s_priv_int,
    declareMethod(s_pub, s_priv_int, x, T_args, T) == s_mthd_id.
    
    
